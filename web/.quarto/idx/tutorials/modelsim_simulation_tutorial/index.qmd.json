{"title":"ModelSim Simulation Tutorial","markdown":{"yaml":{"title":"ModelSim Simulation Tutorial"},"headingText":"Introduction","containsRefs":false,"markdown":"\n\n\n\nTo verify that designs are working, it is useful to simulate them using ModelSim. This document will provide a quick demo of how to perform a simulation in ModelSim and how to include iCE40UP library files in the simulation.\n\n\n# Simple Simulations by Forcing Signals\n\nIf you have a simple design and want to quickly test it out to see that it is working, you can use the force function in the ModelSim command window to apply test inputs and measure the outputs.\n\nWe will use a full adder circuit as a demonstration.\n\n\n::: {#fig-full-adder-schematic}\n![](images/full-adder-schematic.png)\n\nFull adder schematic.\n\n:::\n\n\nTo code up the full adder, first, open ModelSim and create a new ModelSim project titled `ModelSim_Tutorial` and save it in a location where the path name has no spaces. Then create a new file named `fulladder.sv`, making sure the file type is SystemVerilog. You should now have a blank file. Add the Verilog code below to create a structural Verilog model of the full adder circuit show above.\n\n\n::: {#fig-new-project}\n![](images/modelsim-create-project.png)\n\nCreate new project.\n:::\n\n```\n// fulladder.sv\n// Structural Verilog full adder\n// 5/26/22\n// Josh Brake\n// jbrake@hmc.edu\n\nmodule fulladder(\n input   logic A, B, Cin,\n output  logic S, Cout\n);\n\n logic n1, n2, n3;\n\n xor g1(n1, A, B);\n xor g2(S, n1, Cin);\n\n and g3(n2, n1, Cin);\n and g4(n3, A, B);\n\n or  g5(Cout, n2, n3);\n\nendmodule\n```\n\n\nNext, we will simulate the file. First, compile your file via the Compile menu. Then, start the simulation using “Simulate > Start Simulation…”. You will see the GUI change and open up the Objects and Wave panes. You can always toggle windows on or off as desired using the View toolbar menu.\n\nNext, add the selected symbols by selecting them in the Objects pane and adding them to the Wave pane either by using the right-click menu or dragging them.\nNext, to run the simulation, we need to initialize the input values which are floating (HiZ) to begin. \nWe can do this by typing the command `force <Signal Name> <Signal Value>` in the Transcript pane. \nForce `A`, `B`, and `Cin` to some desired values of your choosing and then run the simulation for 10 time units by typing `run 10`.\nWhen you run the simulation, you will see the waves window advance the appropriate number of time points, displaying the values of the signals.\n\n\n::: {#fig-sim-waves-force}\n![](images/modelsim-sim-waves.png)\n\nRunning simulation by forcing signals.\n:::\n\n\nFill out a truth table for a full adder by evaluating the circuit schematic shown above for all combinations of A, B, and Cin and verify a few values by forcing them to get the hang of it.\n\n\n# Testbench Simulation\n\nAfter testing about only two different inputs by manually forcing values you are probably already frustrated with the tediousness of running a simulation this way. Luckily, there is a much more efficient way to run simulations using testbenches.\n\nA testbench is a separate module which generates simulated inputs and enables the generated output signals to be traced versus time. You’ve likely seen testbenches before (e.g., in E85) but you may have never written one from scratch by yourself before. While this is a bit daunting at first, the basic architecture of a testbench is straightforward. Before you proceed, you should review the HDL testbench section in Digital Design and Computer Architecture (Section 4.9 in the ARM edition) which covers several different styles of testbenches.\n\nNote that testbenches include Verilog statements that are non-synthesizable (in other words, they cannot be mapped onto hardware). One example is the initial block, which runs only once at the start of a simulation. In this sense, testbenches use SystemVerilog a bit like a scripting language to enable designs to be easily tested and verified.\n\nIn this example we will create a testbench with automatic checking against a test vector file. This is the most powerful type of testbench and will be a good foundation for all the testbenches you will write for this class.\n\nA testbench is composed of the following elements:\n\n\n* Create and initialize the signals for the inputs, outputs, and internal signals of your modules.\n* Instantiate the device under test (DUT)\n* Generate a simulated clock signal. Even if your module is purely combinational, you will need this clock signal to control when the input test vectors are applied and the outputs checked.\n* Load the test vectors and initialize the signals for the simulation (e.g., pulsing the reset line)\n* Apply the inputs and check the resulting outputs using the test vectors. One simple way to do this is to apply the test vector on the rising edge of the clock and then check the outputs against the expect outputs on the negative edge of the clock.\n\nEvery HDL module that you write should have a testbench to accompany it. While this will cost you some time up front, it will save you loads of time and potential head injuries from banging your head against the wall wondering why your circuit is not working as you expect.\n\n\n## Creating the Testbench\n\nNext, we will create the testbench. Create a new SystemVerilog file “fulladder_tb.sv” and add it to your project. Then, type the following code into the testbench.\n\n\n```\n`timescale 1ns/1ns\n`default_nettype none\n`define N_TV 8\n\nmodule fulladder_tb();\n // Set up test signals\n logic clk, reset;\n logic a, b, cin, s, cout, s_expected, cout_expected;\n logic [31:0] vectornum, errors;\n logic [10:0] testvectors[10000:0]; // Vectors of format s[3:0]_seg[6:0]\n\n // Instantiate the device under test\n fulladder dut(.A(a), .B(b), .Cin(cin), .S(s), .Cout(cout));\n\n // Generate clock signal with a period of 10 timesteps.\n always\n   begin\n     clk = 1; #5;\n     clk = 0; #5;\n   end\n  \n // At the start of the simulation:\n //  - Load the testvectors\n //  - Pulse the reset line (if applicable)\n initial\n   begin\n     $readmemb(\"fulladder_testvectors.tv\", testvectors, 0, `N_TV - 1);\n     vectornum = 0; errors = 0;\n     reset = 1; #27; reset = 0;\n   end\n  // Apply test vector on the rising edge of clk\n always @(posedge clk)\n   begin\n       #1; {a, b, cin, s_expected, cout_expected} = testvectors[vectornum];\n   end\n  initial\n begin\n   // Create dumpfile for signals\n   $dumpfile(\"fulladder_tb.vcd\");\n   $dumpvars(0, fulladder_tb);\n end\n  // Check results on the falling edge of clk\n always @(negedge clk)\n   begin\n     if (~reset) // skip during reset\n       begin\n         if (cout != cout_expected || s != s_expected)\n           begin\n             $display(\"Error: inputs: a=%b, b=%b, cin=%b\", a, b, cin);\n             $display(\" outputs: s=%b (%b expected), cout=%b (%b expected)\", s, s_expected, cout, cout_expected);\n             errors = errors + 1;\n           end\n\n      \n       vectornum = vectornum + 1;\n      \n       if (testvectors[vectornum] === 11'bx)\n         begin\n           $display(\"%d tests completed with %d errors.\", vectornum, errors);\n           $finish;\n         end\n     end\n   end\nendmodule\n```\n\n::: {.hint-box}\n**Note**: Functions preceded by a dollar sign (e.g., `$readmemb`, `$display`, `$finish`, etc.) are system functions.\n:::\n\n## The Testvector (.tv) File\n\nThe test vector file is a plaintext file with a single test vector on each line. Typically these are organized in the format &lt;inputs>_&lt;expected_outputs> (underscores are ignored but help to provide visual organization) but the specific format is up to you. You just need to make sure to assign the bits properly in your testbench module.\n\n\n```\n// fulladder_testvectors.tv\n// Josh Brake\n// jbrake@hmc.edu\n// 5/26/22\n//\n// 5-bit vectors in binary. \n// underscore is ignored\n// // indicates comment\n// a b cin _ s cout\n000_00\n001_10\n010_10\n011_01\n100_10\n101_01\n110_01\n111_11\n```\n\n\n\n# Libraries\n\nIn many instances we want to leverage the iCE40 Technology Library. However, when we go to simulate these designs, we need to make sure to include the appropriate libraries so that ModelSim can find the correct design units when it goes to do the simulation.\n\nWhen you install Lattice Radiant with ModelSim Lattice FPGA Edition, it comes with a set of installed libraries. For our purposes, we are most interested in the iCE40UP library and will need to include this in our simulation.\n\nTo do this, start the simulation by clicking Simulate > Start Simulation. Then navigate to the Libraries tab and add iCE40UP to the Search Libraries window using the “Add…” button.\n\n\n::: {#fig-ice40-tech-library}\n![](images/ice40-tech-library.png)\n\nice40 Technology Library.\n:::\n\n\n\n::: {#fig-ice40-tech-library}\n![](images/ice40-add-library.png)\n\nAdd ice40 Technology Library.\n:::\n\n\n::: {#fig-ice40-start-sim}\n![](images/modelsim-start-sim-module.png)\n\nStart sim with loaded library.\n:::\n\n\nThen navigate to the “Design” tab, select the `top` module and then click OK. \nYour simulation should now start and open up the Wave window. \n\n\n::: {#fig-ice40-tech-library}\n![](images/modelsim-start-sim-module.png)\n\nStart sim of `top` module.\n:::\n\n\n\nNote that you can also achieve the steps above by running `vsim work.top -L iCE40UP` in the command window.\n","srcMarkdownNoYaml":"\n\n\n# Introduction\n\nTo verify that designs are working, it is useful to simulate them using ModelSim. This document will provide a quick demo of how to perform a simulation in ModelSim and how to include iCE40UP library files in the simulation.\n\n\n# Simple Simulations by Forcing Signals\n\nIf you have a simple design and want to quickly test it out to see that it is working, you can use the force function in the ModelSim command window to apply test inputs and measure the outputs.\n\nWe will use a full adder circuit as a demonstration.\n\n\n::: {#fig-full-adder-schematic}\n![](images/full-adder-schematic.png)\n\nFull adder schematic.\n\n:::\n\n\nTo code up the full adder, first, open ModelSim and create a new ModelSim project titled `ModelSim_Tutorial` and save it in a location where the path name has no spaces. Then create a new file named `fulladder.sv`, making sure the file type is SystemVerilog. You should now have a blank file. Add the Verilog code below to create a structural Verilog model of the full adder circuit show above.\n\n\n::: {#fig-new-project}\n![](images/modelsim-create-project.png)\n\nCreate new project.\n:::\n\n```\n// fulladder.sv\n// Structural Verilog full adder\n// 5/26/22\n// Josh Brake\n// jbrake@hmc.edu\n\nmodule fulladder(\n input   logic A, B, Cin,\n output  logic S, Cout\n);\n\n logic n1, n2, n3;\n\n xor g1(n1, A, B);\n xor g2(S, n1, Cin);\n\n and g3(n2, n1, Cin);\n and g4(n3, A, B);\n\n or  g5(Cout, n2, n3);\n\nendmodule\n```\n\n\nNext, we will simulate the file. First, compile your file via the Compile menu. Then, start the simulation using “Simulate > Start Simulation…”. You will see the GUI change and open up the Objects and Wave panes. You can always toggle windows on or off as desired using the View toolbar menu.\n\nNext, add the selected symbols by selecting them in the Objects pane and adding them to the Wave pane either by using the right-click menu or dragging them.\nNext, to run the simulation, we need to initialize the input values which are floating (HiZ) to begin. \nWe can do this by typing the command `force <Signal Name> <Signal Value>` in the Transcript pane. \nForce `A`, `B`, and `Cin` to some desired values of your choosing and then run the simulation for 10 time units by typing `run 10`.\nWhen you run the simulation, you will see the waves window advance the appropriate number of time points, displaying the values of the signals.\n\n\n::: {#fig-sim-waves-force}\n![](images/modelsim-sim-waves.png)\n\nRunning simulation by forcing signals.\n:::\n\n\nFill out a truth table for a full adder by evaluating the circuit schematic shown above for all combinations of A, B, and Cin and verify a few values by forcing them to get the hang of it.\n\n\n# Testbench Simulation\n\nAfter testing about only two different inputs by manually forcing values you are probably already frustrated with the tediousness of running a simulation this way. Luckily, there is a much more efficient way to run simulations using testbenches.\n\nA testbench is a separate module which generates simulated inputs and enables the generated output signals to be traced versus time. You’ve likely seen testbenches before (e.g., in E85) but you may have never written one from scratch by yourself before. While this is a bit daunting at first, the basic architecture of a testbench is straightforward. Before you proceed, you should review the HDL testbench section in Digital Design and Computer Architecture (Section 4.9 in the ARM edition) which covers several different styles of testbenches.\n\nNote that testbenches include Verilog statements that are non-synthesizable (in other words, they cannot be mapped onto hardware). One example is the initial block, which runs only once at the start of a simulation. In this sense, testbenches use SystemVerilog a bit like a scripting language to enable designs to be easily tested and verified.\n\nIn this example we will create a testbench with automatic checking against a test vector file. This is the most powerful type of testbench and will be a good foundation for all the testbenches you will write for this class.\n\nA testbench is composed of the following elements:\n\n\n* Create and initialize the signals for the inputs, outputs, and internal signals of your modules.\n* Instantiate the device under test (DUT)\n* Generate a simulated clock signal. Even if your module is purely combinational, you will need this clock signal to control when the input test vectors are applied and the outputs checked.\n* Load the test vectors and initialize the signals for the simulation (e.g., pulsing the reset line)\n* Apply the inputs and check the resulting outputs using the test vectors. One simple way to do this is to apply the test vector on the rising edge of the clock and then check the outputs against the expect outputs on the negative edge of the clock.\n\nEvery HDL module that you write should have a testbench to accompany it. While this will cost you some time up front, it will save you loads of time and potential head injuries from banging your head against the wall wondering why your circuit is not working as you expect.\n\n\n## Creating the Testbench\n\nNext, we will create the testbench. Create a new SystemVerilog file “fulladder_tb.sv” and add it to your project. Then, type the following code into the testbench.\n\n\n```\n`timescale 1ns/1ns\n`default_nettype none\n`define N_TV 8\n\nmodule fulladder_tb();\n // Set up test signals\n logic clk, reset;\n logic a, b, cin, s, cout, s_expected, cout_expected;\n logic [31:0] vectornum, errors;\n logic [10:0] testvectors[10000:0]; // Vectors of format s[3:0]_seg[6:0]\n\n // Instantiate the device under test\n fulladder dut(.A(a), .B(b), .Cin(cin), .S(s), .Cout(cout));\n\n // Generate clock signal with a period of 10 timesteps.\n always\n   begin\n     clk = 1; #5;\n     clk = 0; #5;\n   end\n  \n // At the start of the simulation:\n //  - Load the testvectors\n //  - Pulse the reset line (if applicable)\n initial\n   begin\n     $readmemb(\"fulladder_testvectors.tv\", testvectors, 0, `N_TV - 1);\n     vectornum = 0; errors = 0;\n     reset = 1; #27; reset = 0;\n   end\n  // Apply test vector on the rising edge of clk\n always @(posedge clk)\n   begin\n       #1; {a, b, cin, s_expected, cout_expected} = testvectors[vectornum];\n   end\n  initial\n begin\n   // Create dumpfile for signals\n   $dumpfile(\"fulladder_tb.vcd\");\n   $dumpvars(0, fulladder_tb);\n end\n  // Check results on the falling edge of clk\n always @(negedge clk)\n   begin\n     if (~reset) // skip during reset\n       begin\n         if (cout != cout_expected || s != s_expected)\n           begin\n             $display(\"Error: inputs: a=%b, b=%b, cin=%b\", a, b, cin);\n             $display(\" outputs: s=%b (%b expected), cout=%b (%b expected)\", s, s_expected, cout, cout_expected);\n             errors = errors + 1;\n           end\n\n      \n       vectornum = vectornum + 1;\n      \n       if (testvectors[vectornum] === 11'bx)\n         begin\n           $display(\"%d tests completed with %d errors.\", vectornum, errors);\n           $finish;\n         end\n     end\n   end\nendmodule\n```\n\n::: {.hint-box}\n**Note**: Functions preceded by a dollar sign (e.g., `$readmemb`, `$display`, `$finish`, etc.) are system functions.\n:::\n\n## The Testvector (.tv) File\n\nThe test vector file is a plaintext file with a single test vector on each line. Typically these are organized in the format &lt;inputs>_&lt;expected_outputs> (underscores are ignored but help to provide visual organization) but the specific format is up to you. You just need to make sure to assign the bits properly in your testbench module.\n\n\n```\n// fulladder_testvectors.tv\n// Josh Brake\n// jbrake@hmc.edu\n// 5/26/22\n//\n// 5-bit vectors in binary. \n// underscore is ignored\n// // indicates comment\n// a b cin _ s cout\n000_00\n001_10\n010_10\n011_01\n100_10\n101_01\n110_01\n111_11\n```\n\n\n\n# Libraries\n\nIn many instances we want to leverage the iCE40 Technology Library. However, when we go to simulate these designs, we need to make sure to include the appropriate libraries so that ModelSim can find the correct design units when it goes to do the simulation.\n\nWhen you install Lattice Radiant with ModelSim Lattice FPGA Edition, it comes with a set of installed libraries. For our purposes, we are most interested in the iCE40UP library and will need to include this in our simulation.\n\nTo do this, start the simulation by clicking Simulate > Start Simulation. Then navigate to the Libraries tab and add iCE40UP to the Search Libraries window using the “Add…” button.\n\n\n::: {#fig-ice40-tech-library}\n![](images/ice40-tech-library.png)\n\nice40 Technology Library.\n:::\n\n\n\n::: {#fig-ice40-tech-library}\n![](images/ice40-add-library.png)\n\nAdd ice40 Technology Library.\n:::\n\n\n::: {#fig-ice40-start-sim}\n![](images/modelsim-start-sim-module.png)\n\nStart sim with loaded library.\n:::\n\n\nThen navigate to the “Design” tab, select the `top` module and then click OK. \nYour simulation should now start and open up the Wave window. \n\n\n::: {#fig-ice40-tech-library}\n![](images/modelsim-start-sim-module.png)\n\nStart sim of `top` module.\n:::\n\n\n\nNote that you can also achieve the steps above by running `vsim work.top -L iCE40UP` in the command window.\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"markdown"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"highlight-style":"ally","output-file":"index.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.330","_quarto-vars":{"microps-color":null},"theme":["cosmo","../../custom.scss"],"monobackgroundcolor":"transparent","title":"ModelSim Simulation Tutorial"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}